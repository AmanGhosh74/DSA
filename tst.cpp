{
  "segtree": {
    "prefix": "segtree",
    "body": [
      "template <typename T>",
      "class segtree",
      "{",
      "public:",
      "    // 0 based indexing",
      "    // def= default value",
      "    vector<T> t;",
      "    int n;",
      "    T def;",
      "    function<T(T, T)> merge;",
      "    void build(int _n, T _def, function<T(T, T)> _fx)",
      "    {",
      "        n = _n;",
      "        def = _def;",
      "        merge = _fx;",
      "        t.assign(n * 2, def);",
      "        for (int i = n - 1; i; i--)",
      "            t[i] = merge(t[i * 2], t[i * 2 + 1]);",
      "    }",
      "    void build(vector<T> &a, T _def, function<T(T, T)> _fx)",
      "    {",
      "        n = a.size();",
      "        def = _def;",
      "        merge = _fx;",
      "        t.assign(n * 2, def);",
      "        for (int i = 0; i < n; i++)",
      "            t[i + n] = T(a[i]);",
      "        for (int i = n - 1; i; i--)",
      "            t[i] = merge(t[i * 2], t[i * 2 + 1]);",
      "    }",
      "    void update(int i, T v)",
      "    {",
      "        for (t[i += n] = T(v); i;)",
      "        {",
      "            i /= 2;",
      "            t[i] = merge(t[i * 2], t[i * 2 + 1]);",
      "        }",
      "    }",
      "    // this query is made on [l, r]",
      "    T query(int l, int r)",
      "    {",
      "        T lans = def, rans = def;",
      "        for (l += n, r += n + 1; l < r; l /= 2, r /= 2)",
      "        {",
      "            if (l % 2)",
      "                lans = merge(lans, t[l++]);",
      "            if (r % 2)",
      "                rans = merge(t[--r], rans);",
      "        }",
      "        return merge(lans, rans);",
      "    }",
      "};",
      "struct node",
      "{",
      "    int val;",
      "    node(int x)",
      "    {",
      "        val = x;",
      "    }",
      "    // default value",
      "    node()",
      "    {",
      "        val = -1e9;",
      "    }",
      "};"
    ],
    "description": ""
  },
  "power": {
    "prefix": "poww",
    "body": [
      "ll Pow(ll a, ll b, ll m = MOD)",
      "{",
      "    ll res = 1;",
      "    while (b)",
      "    {",
      "        if (b & 1)",
      "            res = (res*a) % m;",
      "        a = (a*a) % m;",
      "        b >>= 1;",
      "    }",
      "    return res;",
      "}"
    ],
    "description": ""
  },
  "prime": {
    "prefix": "prime",
    "body": [
      "vector<int> smallest_factor;",
      "vector<bool> prime;",
      "vector<int> primes;",
      "void sieve(int maximum)",
      "{",
      "    maximum = max(maximum, 1);",
      "    smallest_factor.assign(maximum + 1, 0);",
      "    prime.assign(maximum + 1, true);",
      "    prime[0] = prime[1] = false;",
      "    primes = {};",
      "    for (int p = 2; p <= maximum; p++)",
      "        if (prime[p])",
      "        {",
      "            smallest_factor[p] = p;",
      "            primes.push_back(p);",
      "            for (int64_t i = int64_t(p) * p; i <= maximum; i += p)",
      "                if (prime[i])",
      "                {",
      "                    prime[i] = false;",
      "                    smallest_factor[i] = p;",
      "                }",
      "        }",
      "}",
      "",
      "// Determines whether n is prime in worst case O(sqrt n / log n). Requires having run `sieve` up to at least sqrt(n).",
      "// If we've run `sieve` up to at least n, takes O(1) time.",
      "bool is_prime(int64_t n)",
      "{",
      "    int64_t sieve_max = int64_t(smallest_factor.size()) - 1;",
      "    assert(1 <= n && n <= sieve_max * sieve_max);",
      "    if (n <= sieve_max)",
      "        return prime[n];",
      "    for (int64_t p : primes)",
      "    {",
      "        if (p * p > n)",
      "            break;",
      "        if (n % p == 0)",
      "            return false;",
      "    }",
      "    return true;",
      "}",
      "",
      "// Prime factorizes n in worst case O(sqrt n / log n). Requires having run `sieve` up to at least sqrt(n).",
      "// If we've run `sieve` up to at least n, takes O(log n) time.",
      "template <typename T>",
      "vector<pair<T, int>> prime_factorize(T n)",
      "{",
      "    int64_t sieve_max = int64_t(smallest_factor.size()) - 1;",
      "    assert(1 <= n && n <= sieve_max * sieve_max);",
      "    vector<pair<T, int>> result;",
      "    if (n <= sieve_max)",
      "    {",
      "        while (n != 1)",
      "        {",
      "            int p = smallest_factor[n];",
      "            int exponent = 0;",
      "            do",
      "            {",
      "                n /= p;",
      "                exponent++;",
      "            } while (n % p == 0);",
      "            result.emplace_back(p, exponent);",
      "        }",
      "        return result;",
      "    }",
      "    for (int p : primes)",
      "    {",
      "        if (int64_t(p) * p > n)",
      "            break;",
      "        if (n % p == 0)",
      "        {",
      "            result.emplace_back(p, 0);",
      "            do",
      "            {",
      "                n /= p;",
      "                result.back().second++;",
      "            } while (n % p == 0);",
      "        }",
      "    }",
      "    if (n > 1)",
      "        result.emplace_back(n, 1);",
      "    return result;",
      "}",
      "template <typename T>",
      "vector<T> generate_factors(const vector<pair<T, int>> &prime_factors, bool sorted = false)",
      "{",
      "    // See http://oeis.org/A066150 and http://oeis.org/A036451 for upper bounds on number of factors.",
      "    static vector<T> buffer;",
      "    int product = 1;",
      "    for (auto &pf : prime_factors)",
      "        product *= pf.second + 1;",
      "    vector<T> factors = {1};",
      "    factors.reserve(product);",
      "    if (sorted)",
      "        buffer.resize(product);",
      "    for (auto &pf : prime_factors)",
      "    {",
      "        T p = pf.first;",
      "        int exponent = pf.second;",
      "        int before_size = int(factors.size());",
      "        for (int i = 0; i < exponent * before_size; i++)",
      "            factors.push_back(factors[factors.size() - before_size] * p);",
      "        if (sorted && factors[before_size - 1] > p)",
      "            for (int section = before_size; section < int(factors.size()); section *= 2)",
      "                for (int i = 0; i + section < int(factors.size()); i += 2 * section)",
      "                {",
      "                    int length = min(2 * section, int(factors.size()) - i);",
      "                    merge(factors.begin() + i, factors.begin() + i + section,",
      "                          factors.begin() + i + section, factors.begin() + i + length,",
      "                          buffer.begin());",
      "                    copy(buffer.begin(), buffer.begin() + length, factors.begin() + i);",
      "                }",
      "    }",
      "    assert(int(factors.size()) == product);",
      "    return factors;",
      "}"
    ],
    "description": ""
  },
  "sdf": {
    "prefix": "dsu",
    "body": [
      "struct union_find",
      "{",
      "    vector<int> parent;",
      "    vector<int> size;",
      "    int components = 0;",
      "",
      "    union_find(int n = -1)",
      "    {",
      "        if (n >= 0)",
      "            init(n);",
      "    }",
      "",
      "    void init(int n)",
      "    {",
      "        parent.resize(n + 1);",
      "        iota(parent.begin(), parent.end(), 0);",
      "        size.assign(n + 1, 1);",
      "        components = n;",
      "    }",
      "",
      "    int find(int x)",
      "    {",
      "        return x == parent[x] ? x : parent[x] = find(parent[x]);",
      "    }",
      "",
      "    bool unite(int x, int y)",
      "    {",
      "        x = find(x);",
      "        y = find(y);",
      "",
      "        if (x == y)",
      "            return false;",
      "",
      "        if (size[x] < size[y])",
      "            swap(x, y);",
      "",
      "        parent[y] = x;",
      "        size[x] += size[y];",
      "        components--;",
      "        return true;",
      "    }",
      "};"
    ],
    "description": ""
  },
  "BIT": {
    "prefix": "BIT",
    "body": [
      "template <class T>",
      "class BIT",
      "{",
      "    static_assert(is_integral<T>::value, \"Integer required\");",
      "",
      "private:",
      "    const size_t N;",
      "    vector<T> data;",
      "",
      "public:",
      "    // Binary indexed tree or fenwick tree",
      "    // O (log n) all operations except order",
      "    // order complexity - O (log n)",
      "    // 1 based indexing",
      "    BIT() : N(0) {}",
      "    BIT(const size_t _N) : N(_N), data(_N + 1) {}",
      "",
      "    size_t size()",
      "    {",
      "        return N;",
      "    }",
      "    // sum of [1, idx]",
      "    // range sum query",
      "    T sum(size_t idx)",
      "    {",
      "        assert(idx > 0);",
      "        T ans = 0;",
      "        for (; idx > 0; idx -= (idx & -idx))",
      "        {",
      "            ans += data[idx];",
      "        }",
      "        return ans;",
      "    }",
      "    T sum(size_t l, size_t r)",
      "    {",
      "        assert(l <= r);",
      "        if (l == 1 or l == 0)",
      "            return sum(r);",
      "        return sum(r) - sum(l - 1);",
      "    }",
      "",
      "    // Point update",
      "    void add(size_t idx, T val)",
      "    {",
      "        assert(idx > 0);",
      "        for (; idx <= N; idx += (idx & -idx))",
      "        {",
      "            data[idx] += val;",
      "        }",
      "    }",
      "",
      "    // Range update",
      "    void range_add(size_t l, size_t r, T val)",
      "    {",
      "        assert(l <= r);",
      "        assert(l > 0);",
      "        add(l, val);",
      "        add(r + 1, -val);",
      "    }",
      "    template <class OStream>",
      "    friend OStream &operator<<(OStream &os, BIT &bit)",
      "    {",
      "        T prv = 0;",
      "        os << '[';",
      "        for (int i = 1; i <= bit.N; i++)",
      "        {",
      "            T now = bit.sum(i);",
      "            os << now - prv << ',', prv = now;",
      "        }",
      "        return os << ']';",
      "    }",
      "    int order(T sum)",
      "    {",
      "        // find kth smallest element",
      "        // if doesn't exists return 0",
      "        int mxind = 0;",
      "        while (1 << (mxind + 1) <= N)",
      "            mxind++;",
      "        int pos = 0;",
      "        while (mxind >= 0)",
      "        {",
      "            if (pos + (1 << mxind) <= N && data[pos + (1 << mxind)] < sum)",
      "            {",
      "                pos += (1 << mxind);",
      "                sum -= data[pos];",
      "            }",
      "            mxind--;",
      "        }",
      "        return pos + 1;",
      "    }",
      "    // You can either do one of the following",
      "    // 1. Range update and point query",
      "    // 2. Point update and range query",
      "};"
    ],
    "description": ""
  },
  "LCA": {
    "prefix": "LCA",
    "body": [
      "struct ancestors {",
      "    int n, level, root, tin;",
      "    vector <vector<int>> st;",
      "    vector<vector<int>> adj;",
      "    vector <int> p, d, t;",
      " ",
      "    ancestors() {}",
      "    ancestors(int n, int root, vector<vector<int>> &adj) : n(n), root(root), adj(adj) {",
      "    tin = 0;",
      "        level = log2(n) + 1;",
      "        st.assign(n + 1, vector <int> (level, -1));",
      "        p.assign(n + 1, 0);",
      "        d.assign(n + 1, 0);",
      "        t.assign(n + 1, 0);",
      "        fillst();",
      "    }",
      " ",
      "    void findpar(int x, int par) {",
      "        p[x] = par;",
      "        for (auto it : adj[x]) {",
      "           if(it!=par){",
      "            d[it] = d[x] + 1;",
      "            findpar(it, x);",
      "           } ",
      "        }",
      "        t[x] = tin++;",
      "    }",
      " ",
      "    void fillst() {",
      "        findpar(root, 0);",
      "        for (int j = 0; j < level; j++) {",
      "            for (int i = 1; i <= n; i++) {",
      "                if (j == 0) st[i][j] = p[i];",
      "                else if (st[i][j - 1] != -1) st[i][j] = st[st[i][j - 1]][j - 1];",
      "            }",
      "        }",
      "    }",
      " ",
      "    int kth(int x, int k) {",
      "        for (int i = level - 1; i >= 0; i--) {",
      "            if (k >= (1 << i)) {",
      "                x = st[x][i];",
      "                k -= (1 << i);",
      "            }",
      "        }",
      "        return x;",
      "    }",
      " ",
      "    int lca(int x, int y) {",
      "        if (d[y] < d[x]) swap(x, y);",
      "        y = kth(y, d[y] - d[x]);",
      "        if (x == y) return x;",
      " ",
      "        for (int i = level - 1; i >= 0; i--) {",
      "            if (st[x][i] != -1 && st[x][i] != st[y][i]) {",
      "                x = st[x][i];",
      "                y = st[y][i];",
      "            }",
      "        }",
      "        // 0 for root ",
      "        return st[x][0];",
      "    }",
      " ",
      "    int distance(int u, int v) {",
      "        return d[u] + d[v] - 2 * d[lca(u, v)];",
      "    }",
      "};"
    ],
    "description": ""
  },
  "": {
    "prefix": "matrix",
    "body": [
      " ",
      "struct Matrix {",
      "    static const ll M = MOD;",
      "    static const ll SQMOD = M * M;",
      "    static ll const N = 10;",
      "    ll mat[N][N];",
      "    ll n, m;",
      "    Matrix(ll _n = N, ll _m = N, ll val = 0) : n(_n), m(_m) {",
      "        for (ll i = 0; i < n; ++i)",
      "            for (ll j = 0; j < m; ++j)",
      "                mat[i][j] = val;",
      "    }",
      "    Matrix(const vector<vector<ll>> &&other) {",
      "        n = ll(other.size());",
      "        m = ll(other[0].size());",
      "        for (ll i = 0; i < n; ++i)",
      "            for (ll j = 0; j < m; ++j)",
      "                mat[i][j] = other[i][j];",
      "    }",
      "    Matrix &operator=(const vector<vector<ll>> &&other) {",
      "        return *this = Matrix(forward<decltype(other)>(other));",
      "    }",
      "    ll *operator[](ll r) { return mat[r]; }",
      "    const ll *operator[](ll r) const { return mat[r]; }",
      "    static Matrix unit(ll n) {",
      "        Matrix res(n, n);",
      "        for (ll i = 0; i < n; i++) res[i][i] = 1;",
      "        return res;",
      "    }",
      "    Matrix &operator+=(const Matrix &rhs) {",
      "        assert(n == rhs.n && m == rhs.m);",
      "        for (ll i = 0; i < n; ++i)",
      "            for (ll j = 0; j < m; ++j) {",
      "                mat[i][j] += rhs[i][j];",
      "                if (mat[i][j] >= M) mat[i][j] -= M;",
      "            }",
      "        return *this;",
      "    }",
      "    Matrix operator+(const Matrix &rhs) const {",
      "        Matrix lhs(*this);",
      "        return lhs += rhs;",
      "    }",
      "    friend Matrix operator*(const Matrix &A, const Matrix &B) {",
      "        assert(A.m == B.n);",
      "        Matrix res(A.n, B.m);",
      "        for (ll i = 0; i < res.n; i++)",
      "            for (ll j = 0; j < res.m; j++) {",
      "                ll sum = 0LL;",
      "                for (ll k = 0; k < A.m; k++) {",
      "                    sum += A[i][k] * B[k][j];",
      "                    if (sum >= SQMOD) sum -= SQMOD;",
      "                }",
      "                res[i][j] = (sum % M);",
      "            }",
      "        return res;",
      "    }",
      "    friend Matrix power(Matrix base, long long ex) {",
      "        assert(base.n == base.m);",
      "        Matrix res = Matrix::unit(base.n);",
      "        while (ex > 0) {",
      "            if (ex & 1) res = res * base;",
      "            base = base * base;",
      "            ex >>= 1;",
      "        }",
      "        return res;",
      "    }",
      "    friend string to_string(const Matrix &a) {",
      "        string res = \"\\n\";",
      "        for (ll i = 0; i < a.n; ++i) {",
      "            res += '{';",
      "            for (ll j = 0; j < a.m; ++j) {",
      "                res += std::to_string(a.mat[i][j]);",
      "                if (j != a.m - 1) res += \", \";",
      "            }",
      "            res += \"}\\n\";",
      "        }",
      "        res.append(\"\\n\");",
      "        return res;",
      "    }",
      "    Matrix &operator*=(const Matrix &rhs) { return *this = *this * rhs; }",
      "};"
    ],
    "description": ""
  },
  "sparse": {
    "prefix": "sparse",
    "body": [
      "template<class T>",
      "class sparseTable",
      "{",
      "    public:",
      "    int n,k;",
      "    vector<vector<T>> table;",
      "    vector<T> logs;",
      "    function<T(T,T)> operation;",
      "    void init(int x,function<T(T,T)> _operation)",
      "    {  ",
      "            operation=_operation;",
      "            n=x;",
      "            logs.resize(n+1);",
      "            logs[1]=0;",
      "            for(int i=2;i<=n;i++)",
      "                    logs[i]=logs[i/2]+1;",
      "            k=*max_element(logs.begin(),logs.end());",
      "            table.resize(k+1,vector<T>(n));",
      "    }",
      "",
      "    void build(vector<T> &arr)",
      "    {",
      "        for(int i=0;i<n;i++)",
      "                table[0][i]=arr[i];",
      " ",
      "        for(int j=1;j<=k;j++)",
      "        {",
      "            for(int i=0;i+(1<<j)<=n;i++)",
      "                table[j][i]=operation(table[j-1][i],table[j-1][i+(1<<(j-1))]);",
      "        }",
      "    }",
      "    // 1 based indexing",
      "    T query(int l , int r)",
      "    {",
      "        assert(l<=r);",
      "        assert(l>=0 && r<n);",
      "        int j = logs[r - l + 1];",
      "        T answer = operation(table[j][l], table[j][r-(1<<j)+1]);",
      "        return answer;",
      "    }",
      "};"
    ],
    "description": ""
  },
  "lazyseg": {
    "prefix": "lazyseg",
    "body": [
      "struct segment_change",
      "{",
      "    // Use a sentinel value rather than a boolean to save significant memory (4-8 bytes per object).",
      "    static const int SENTINEL = numeric_limits<int>::lowest();",
      "",
      "    // Note that to_set goes first, and to_add goes after.",
      "    // TODO: check if these values can overflow int.",
      "    int to_set, to_add;",
      "",
      "    // TODO: make sure the default constructor is the identity segment_change.",
      "    segment_change(int _to_add = 0, int _to_set = SENTINEL) : to_set(_to_set), to_add(_to_add) {}",
      "",
      "    bool has_set() const",
      "    {",
      "        return to_set != SENTINEL;",
      "    }",
      "",
      "    bool has_change() const",
      "    {",
      "        return has_set() || to_add != 0;",
      "    }",
      "",
      "    // Return the combined result of applying this segment_change followed by `other`.",
      "    // TODO: make sure to check for sentinel values.",
      "    segment_change combine(const segment_change &other) const",
      "    {",
      "        if (other.has_set())",
      "            return other;",
      "",
      "        return segment_change(to_add + other.to_add, to_set);",
      "    }",
      "};",
      "",
      "struct segment",
      "{",
      "    // TODO: check if these values can overflow int.",
      "    int maximum;",
      "    int sum;",
      "    int first, last, max_diff;",
      "",
      "    // TODO: make sure the default constructor is the identity segment.",
      "    segment(int _maximum = numeric_limits<int>::lowest(), int64_t _sum = 0, int _first = 0, int _last = 0,",
      "            int _max_diff = -1) : maximum(_maximum), sum(_sum), first(_first), last(_last), max_diff(_max_diff) {}",
      "",
      "    bool empty() const",
      "    {",
      "        return max_diff < 0;",
      "    }",
      "",
      "    void apply(int length, const segment_change &change)",
      "    {",
      "        if (change.has_set())",
      "        {",
      "            maximum = change.to_set;",
      "            sum = int64_t(length) * change.to_set;",
      "            first = last = change.to_set;",
      "            max_diff = 0;",
      "        }",
      "",
      "        maximum += change.to_add;",
      "        sum += int64_t(length) * change.to_add;",
      "        first += change.to_add;",
      "        last += change.to_add;",
      "    }",
      "",
      "    void join(const segment &other)",
      "    {",
      "        if (empty())",
      "        {",
      "            *this = other;",
      "            return;",
      "        }",
      "        else if (other.empty())",
      "        {",
      "            return;",
      "        }",
      "",
      "        maximum = max(maximum, other.maximum);",
      "        sum += other.sum;",
      "        max_diff = max({max_diff, other.max_diff, abs(last - other.first)});",
      "        last = other.last;",
      "    }",
      "",
      "    // TODO: decide whether to re-implement this for better performance. Mainly relevant when segments contain arrays.",
      "    void join(const segment &seg0, const segment &seg1)",
      "    {",
      "        *this = seg0;",
      "        join(seg1);",
      "    }",
      "};",
      "",
      "struct seg_tree",
      "{",
      "    static int highest_bit(unsigned x)",
      "    {",
      "        return x == 0 ? -1 : 31 - __builtin_clz(x);",
      "    }",
      "",
      "    int tree_n = 0;",
      "    vector<segment> tree;",
      "    vector<segment_change> changes;",
      "",
      "    seg_tree(int n = -1)",
      "    {",
      "        if (n >= 0)",
      "            init(n);",
      "    }",
      "",
      "    void init(int n)",
      "    {",
      "        tree_n = 1;",
      "",
      "        while (tree_n < n)",
      "            tree_n *= 2;",
      "",
      "        tree.assign(2 * tree_n, {});",
      "        changes.assign(tree_n, {});",
      "    }",
      "",
      "    // Builds our tree from an array in O(n).",
      "    void build(const vector<segment> &initial)",
      "    {",
      "        int n = (initial.size());",
      "        init(n);",
      "        copy(initial.begin(), initial.end(), tree.begin() + tree_n);",
      "",
      "        for (int position = tree_n - 1; position > 0; position--)",
      "            tree[position].join(tree[2 * position], tree[2 * position + 1]);",
      "    }",
      "",
      "    void apply_and_combine(int position, int length, const segment_change &change)",
      "    {",
      "        tree[position].apply(length, change);",
      "",
      "        if (position < tree_n)",
      "            changes[position] = changes[position].combine(change);",
      "    }",
      "",
      "    void push_down(int position, int length)",
      "    {",
      "        if (changes[position].has_change())",
      "        {",
      "            apply_and_combine(2 * position, length / 2, changes[position]);",
      "            apply_and_combine(2 * position + 1, length / 2, changes[position]);",
      "            changes[position] = segment_change();",
      "        }",
      "    }",
      "",
      "    template <typename T_range_op>",
      "    void process_range(int position, int start, int end, int a, int b, bool needs_join, T_range_op &&range_op)",
      "    {",
      "        if (a <= start && end <= b)",
      "        {",
      "            range_op(position, end - start);",
      "            return;",
      "        }",
      "",
      "        if (position >= tree_n)",
      "            return;",
      "",
      "        push_down(position, end - start);",
      "        int mid = (start + end) / 2;",
      "        if (a < mid)",
      "            process_range(2 * position, start, mid, a, b, needs_join, range_op);",
      "        if (b > mid)",
      "            process_range(2 * position + 1, mid, end, a, b, needs_join, range_op);",
      "        if (needs_join)",
      "            tree[position].join(tree[2 * position], tree[2 * position + 1]);",
      "    }",
      "",
      "    segment query(int a, int b)",
      "    {",
      "        assert(0 <= a && a <= b && b <= tree_n);",
      "        segment answer;",
      "",
      "        process_range(1, 0, tree_n, a, b, false, [&](int position, int) -> void",
      "                      { answer.join(tree[position]); });",
      "",
      "        return answer;",
      "    }",
      "",
      "    segment query_full() const",
      "    {",
      "        return tree[1];",
      "    }",
      "",
      "    segment query_single(int index)",
      "    {",
      "        assert(0 <= index && index < tree_n);",
      "        int position = tree_n + index;",
      "",
      "        for (int up = highest_bit(tree_n); up > 0; up--)",
      "            push_down(position >> up, 1 << up);",
      "",
      "        return tree[position];",
      "    }",
      "",
      "    void update(int a, int b, const segment_change &change)",
      "    {",
      "        assert(0 <= a && a <= b && b <= tree_n);",
      "",
      "        process_range(1, 0, tree_n, a, b, true, [&](int position, int length) -> void",
      "                      { apply_and_combine(position, length, change); });",
      "    }",
      "",
      "    void update_single(int index, const segment &seg)",
      "    {",
      "        assert(0 <= index && index < tree_n);",
      "        int position = tree_n + index;",
      "",
      "        for (int up = highest_bit(tree_n); up > 0; up--)",
      "            push_down(position >> up, 1 << up);",
      "",
      "        tree[position] = seg;",
      "",
      "        while (position > 1)",
      "        {",
      "            position /= 2;",
      "            tree[position].join(tree[2 * position], tree[2 * position + 1]);",
      "        }",
      "    }",
      "",
      "    vector<segment> to_array(int n)",
      "    {",
      "        for (int i = 1; i < tree_n; i++)",
      "            push_down(i, tree_n >> highest_bit(i));",
      "",
      "        return vector<segment>(tree.begin() + tree_n, tree.begin() + tree_n + n);",
      "    }",
      "};",
      ""
    ],
    "description": ""
  },
  "SCC": {
    "prefix": "SCC",
    "body": [
      "struct DirectedGraph",
      "{",
      "    int n;",
      "    vector<vector<int>> g, gr;",
      "    vector<bool> used;",
      "    vector<int> ord, comp;",
      "",
      "    vector<int> compOf;",
      "    int nc;",
      "",
      "    vector<int> indegree, source;",
      "",
      "    DirectedGraph(int _n) : n(_n)",
      "    {",
      "        nc = 0;",
      "        compOf = vector<int>(n);",
      "        g = vector<vector<int>>(n);",
      "        gr = vector<vector<int>>(n);",
      "        indegree = vector<int>(n);",
      "        source = vector<int>(n);",
      "    }",
      "",
      "    void add_edge(int i, int j)",
      "    {",
      "        g[i].push_back(j);",
      "        gr[j].push_back(i);",
      "    }",
      "",
      "    void init()",
      "    {",
      "        for (int i = 0; i < n; ++i)",
      "        {",
      "            sort(begin(g[i]), end(g[i]));",
      "            sort(begin(gr[i]), end(gr[i]));",
      "            g[i].erase(unique(begin(g[i]), end(g[i])), end(g[i]));",
      "            gr[i].erase(unique(begin(gr[i])), end(gr[i]));",
      "        }",
      "        for (int i = 0; i < n; ++i)",
      "        {",
      "            for (int j : g[i])",
      "            {",
      "                ++indegree[j];",
      "            }",
      "        }",
      "        for (int i = 0; i < n; ++i)",
      "            source[i] = indegree[i] == 0;",
      "    }",
      "",
      "    void dfs1(int v)",
      "    {",
      "        used[v] = true;",
      "        for (auto a : g[v])",
      "        {",
      "            if (!used[a])",
      "                dfs1(a);",
      "        }",
      "        ord.push_back(v);",
      "    }",
      "",
      "    void dfs2(int v)",
      "    {",
      "        used[v] = true;",
      "        comp.push_back(v);",
      "        for (auto a : gr[v])",
      "        {",
      "            if (!used[a])",
      "                dfs2(a);",
      "        }",
      "    }",
      "",
      "    void findSCCs()",
      "    {",
      "        ord.clear();",
      "        used.assign(n, false);",
      "        for (int i = 0; i < n; ++i)",
      "        {",
      "            if (!used[i])",
      "                dfs1(i);",
      "        }",
      "        used.assign(n, false);",
      "        for (int i = 0; i < n; ++i)",
      "        {",
      "            int v = ord[n - 1 - i];",
      "            if (!used[v])",
      "            {",
      "                dfs2(v);",
      "                for (int a : comp)",
      "                {",
      "                    compOf[a] = nc;",
      "                }",
      "                nc++;",
      "                comp.clear();",
      "            }",
      "        }",
      "    }",
      "",
      "    pair<DirectedGraph, vector<int>> createCondensationGraph()",
      "    {",
      "        findSCCs();",
      "        DirectedGraph ret(nc);",
      "        for (int i = 0; i < n; ++i)",
      "        {",
      "            int c = compOf[i];",
      "            for (int j : g[i])",
      "            {",
      "                int d = compOf[j];",
      "                if (c != d)",
      "                {",
      "                    ret.add_edge(c, d);",
      "                }",
      "            }",
      "        }",
      "        ret.init();",
      "        return {ret, compOf};",
      "    }",
      "};"
    ],
    "description": ""
  },
  "mint": {
    "prefix": "mint",
    "body": [
      "const int MOD = 998244353;",
      "struct mi",
      "{",
      "    int val;",
      "    mi(long long v = 0)",
      "    {",
      "        if (v < 0)",
      "        {",
      "            v = v % MOD + MOD;",
      "        }",
      "        if (v >= MOD)",
      "        {",
      "            v %= MOD;",
      "        }",
      "        val = v;",
      "    }",
      "    static int mod_inv(int a, int m = MOD)",
      "    {",
      "        int g = m, r = a, x = 0, y = 1;",
      "        while (r != 0)",
      "        {",
      "            int q = g / r;",
      "            g %= r;",
      "            swap(g, r);",
      "            x -= q * y;",
      "            swap(x, y);",
      "        }",
      "        return x < 0 ? x + m : x;",
      "    }",
      "    explicit operator int() const",
      "    {",
      "        return val;",
      "    }",
      "    mi &operator+=(const mi &other)",
      "    {",
      "        val += other.val;",
      "        if (val >= MOD)",
      "            val -= MOD;",
      "        return *this;",
      "    }",
      "    mi &operator-=(const mi &other)",
      "    {",
      "        val -= other.val;",
      "        if (val < 0)",
      "            val += MOD;",
      "        return *this;",
      "    }",
      "    typedef unsigned long long ull;",
      "    ull fast_mod(ull a, ull b, ull M = MOD)",
      "    {",
      "        long long ret = a * b - M * ull(1.L / M * a * b);",
      "        return ret + M * (ret < 0) - M * (ret >= (long long)M);",
      "    }",
      "    mi &operator*=(const mi &other)",
      "    {",
      "        val = fast_mod((ull)val, other.val);",
      "        return *this;",
      "    }",
      "    mi &operator/=(const mi &other)",
      "    {",
      "        return *this *= other.inv();",
      "    }",
      "    friend mi operator+(const mi &a, const mi &b) { return mi(a) += b; }",
      "    friend mi operator-(const mi &a, const mi &b) { return mi(a) -= b; }",
      "    friend mi operator*(const mi &a, const mi &b) { return mi(a) *= b; }",
      "    friend mi operator/(const mi &a, const mi &b) { return mi(a) /= b; }",
      "    mi &operator++()",
      "    {",
      "        val = val == MOD - 1 ? 0 : val + 1;",
      "        return *this;",
      "    }",
      "    mi &operator--()",
      "    {",
      "        val = val == 0 ? MOD - 1 : val - 1;",
      "        return *this;",
      "    }",
      "    mi operator++(int32_t)",
      "    {",
      "        mi before = *this;",
      "        ++*this;",
      "        return before;",
      "    }",
      "    mi operator--(int32_t)",
      "    {",
      "        mi before = *this;",
      "        --*this;",
      "        return before;",
      "    }",
      "    mi operator-() const",
      "    {",
      "        return val == 0 ? 0 : MOD - val;",
      "    }",
      "    bool operator==(const mi &other) const { return val == other.val; }",
      "    bool operator!=(const mi &other) const { return val != other.val; }",
      "    mi inv() const",
      "    {",
      "        return mod_inv(val);",
      "    }",
      "    mi pow(long long p) const",
      "    {",
      "        assert(p >= 0);",
      "        mi a = *this, result = 1;",
      "",
      "        while (p > 0)",
      "        {",
      "            if (p & 1)",
      "                result *= a;",
      "",
      "            a *= a;",
      "            p >>= 1;",
      "        }",
      "        return result;",
      "    }",
      "    friend ostream &operator<<(ostream &stream, const mi &m)",
      "    {",
      "        return stream << m.val;",
      "    }",
      "    friend istream &operator>>(istream &stream, mi &m)",
      "    {",
      "        return stream >> m.val;",
      "    }",
      "    friend void __print(const mi &x)",
      "    {",
      "        cerr << x.val;",
      "    }",
      "};",
      "const int32_t N = 2e5 + 10;",
      "",
      "mi FAC[N + 1], INV[N + 1];",
      "void calc()",
      "{",
      "    FAC[0] = 1;",
      "    for (int i = 1; i <= N; i++)",
      "    {",
      "        FAC[i] = (FAC[i - 1] * i);",
      "    }",
      "    INV[N] = INV[N].mod_inv(FAC[N].val, MOD);",
      "    for (int i = N - 1; i >= 0; i--)",
      "    {",
      "        INV[i] = (INV[i + 1] * (i + 1));",
      "    }",
      "}",
      "mi ncr(int n, int r)",
      "{",
      "    if (r < 0)",
      "        return 0;",
      "    if (n < r)",
      "        return 0;",
      "    if (r == 0)",
      "        return 1;",
      "     assert(n < N);",
      "    mi a = FAC[n] * INV[r] * INV[n - r];",
      "    return a;",
      "}"
    ],
    "description": ""
  },
  "hash": {
    "prefix": "Hash",
    "body": [
      "using ll = long long;",
      "",
      "template <int... mods>",
      "struct StringHash",
      "{",
      "    StringHash(const string &s) {}",
      "    int hashval(int l1, int r2)",
      "    {",
      "        return 0;",
      "    }",
      "    int compare(int l1, int r1, int l2, int r2)",
      "    {",
      "        return true;",
      "    }",
      "};",
      "template <int mod, int... mods>",
      "struct StringHash<mod, mods...>",
      "{",
      "    StringHash() {}",
      "    int modpow(ll x, ll p)",
      "    {",
      "        ll ans = 1;",
      "        while (p)",
      "        {",
      "            if (p & 1)",
      "                ans *= x, ans %= mod;",
      "            x *= x;",
      "            x %= mod;",
      "            p >>= 1;",
      "        }",
      "        return int(ans);",
      "    }",
      "    vector<int> hashvalues;",
      "    vector<int> pows;",
      "    vector<int> invpows;",
      "    StringHash<mods...> ohash;",
      "    const int AL = 26;",
      "    StringHash(const string &s) : ohash(s)",
      "    {",
      "        int n = s.size();",
      "        hashvalues.resize(n + 1);",
      "        pows.resize(n + 1);",
      "        invpows.resize(n + 1);",
      "        pows[0] = 1;",
      "        for (int i = 1; i <= n; i++)",
      "        {",
      "            pows[i] = ll(AL + 1) * pows[i - 1] % mod;",
      "        }",
      "        invpows[n] = modpow(pows[n], mod - 2);",
      "        for (int i = n - 1; i >= 0; --i)",
      "        {",
      "            invpows[i] = ll(AL + 1) * invpows[i + 1] % mod;",
      "        }",
      "        for (int i = 1; i <= n; i++)",
      "        {",
      "            hashvalues[i] = (ll(AL + 1) * hashvalues[i - 1] + (s[i - 1] - 'a' + 1)) % mod;",
      "        }",
      "    }",
      "    int hashval(int l1, int r1)",
      "    { // 0 indexed",
      "        ll ans = hashvalues[r1 + 1] - ll(hashvalues[l1]) * pows[r1 - l1 + 1];",
      "        ans %= mod;",
      "        return ans >= 0 ? ans : ans + mod;",
      "    }",
      "    bool compare(int l1, int r1, int l2, int r2)",
      "    {",
      "        return hashval(l1, r1) == hashval(l2, r2) && ohash.compare(l1, r1, l2, r2);",
      "    }",
      "};"
    ],
    "description": ""
  },
  "KMP": {
    "prefix": "KMP",
    "body": [
      "template <class P, class Q>",
      "class String",
      "{",
      "public:",
      "    vector<P> Z(Q &a)",
      "    {",
      "        int n = size(a);",
      "        vector<P> z(n);",
      "        for (int i = 1, l = 0, r = 0; i < n; i++)",
      "        {",
      "            if (i <= r)",
      "                z[i] = min(z[i - l], r - i + 1);",
      "            while (i + z[i] < n and a[i + z[i]] == a[z[i]])",
      "                z[i]++;",
      "            if (i + z[i] - 1 > r)",
      "                r = z[i] + i - 1, l = i;",
      "        }",
      "        return z;",
      "    }",
      "    vector<P> KMP(Q &a)",
      "    {",
      "        int n = size(a);",
      "        vector<P> p(n);",
      "        for (int i = 1; i < n; i++)",
      "        {",
      "            int j = p[i - 1];",
      "            while (j > 0 and a[i] != a[j])",
      "                j = p[j - 1];",
      "            p[i] = (j += (a[i] == a[j]));",
      "        }",
      "        return p;",
      "    }",
      "};"
    ],
    "description": ""
  },
  "cp template": {
    "prefix": "xp",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "using namespace __gnu_pbds;",
      "using namespace std;",
      "#ifndef ONLINE_JUDGE",
      "#include \"debug.h\"",
      "#else",
      "#define dbg(x...)",
      "#endif",
      "#define int long long",
      "#define endl '\\n'",
      "typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;",
      "typedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;",
      "typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pset;",
      "int32_t main()",
      "{",
      "    ios_base::sync_with_stdio(0);",
      "    cin.tie(0);",
      "    auto solve = [&](int tc) {",
      "    };",
      "    int tc = 1;",
      "    cin >> tc;",
      "    for (int i = 1; i <= tc; i++)",
      "    {",
      "        solve(i);",
      "    }",
      "}"
    ],
    "description": ""
  },
  "LCA2": {
    "prefix": "LCA2",
    "body": [
      "struct LCA {",
      "    int n = 0;",
      "    vector<vector<int>> adj;",
      "    vector<int> parent, depth, subtree_size;",
      "    vector<int> euler, first_occurrence;",
      "    vector<int> tour_start, tour_end;",
      "    vector<int> tour_list, rev_tour_list;",
      "    vector<int> heavy_root;",
      "    vector<int> heavy_root_depth, heavy_root_parent;  // These two vectors serve purely to optimize get_kth_ancestor",
      "    RMQ<int> rmq;",
      "    bool built = false;",
      " ",
      "    LCA(int _n = 0) {",
      "        init(_n);",
      "    }",
      " ",
      "    // Warning: this does not call build().",
      "    LCA(const vector<vector<int>> &_adj) {",
      "        init(_adj);",
      "    }",
      " ",
      "    void init(int _n) {",
      "        n = _n;",
      "        adj.assign(n, {});",
      "        parent.resize(n);",
      "        depth.resize(n);",
      "        subtree_size.resize(n);",
      "        first_occurrence.resize(n);",
      "        tour_start.resize(n);",
      "        tour_end.resize(n);",
      "        tour_list.resize(n);",
      "        heavy_root.resize(n);",
      "        built = false;",
      "    }",
      " ",
      "    // Warning: this does not call build().",
      "    void init(const vector<vector<int>> &_adj) {",
      "        init(int(_adj.size()));",
      "        adj = _adj;",
      "    }",
      " ",
      "    void add_edge(int a, int b) {",
      "        adj[a].push_back(b);",
      "        adj[b].push_back(a);",
      "    }",
      " ",
      "    int degree(int v) const {",
      "        return int(adj[v].size()) + (built && parent[v] >= 0);",
      "    }",
      " ",
      "    void dfs(int node, int par) {",
      "        parent[node] = par;",
      "        depth[node] = par < 0 ? 0 : depth[par] + 1;",
      "        subtree_size[node] = 1;",
      " ",
      "        // Erase the edge to parent.",
      "        adj[node].erase(remove(adj[node].begin(), adj[node].end(), par), adj[node].end());",
      " ",
      "        for (int child : adj[node]) {",
      "            dfs(child, node);",
      "            subtree_size[node] += subtree_size[child];",
      "        }",
      " ",
      "        // Heavy-light subtree reordering.",
      "        sort(adj[node].begin(), adj[node].end(), [&](int a, int b) {",
      "            return subtree_size[a] > subtree_size[b];",
      "        });",
      "    }",
      " ",
      "    int tour;",
      " ",
      "    void tour_dfs(int node, bool heavy) {",
      "        heavy_root[node] = heavy ? heavy_root[parent[node]] : node;",
      "        first_occurrence[node] = int(euler.size());",
      "        euler.push_back(node);",
      "        tour_list[tour] = node;",
      "        tour_start[node] = tour++;",
      "        bool heavy_child = true;",
      " ",
      "        for (int child : adj[node]) {",
      "            tour_dfs(child, heavy_child);",
      "            euler.push_back(node);",
      "            heavy_child = false;",
      "        }",
      " ",
      "        tour_end[node] = tour;",
      "    }",
      " ",
      "    void build(vector<int> roots = {}, bool build_rmq = true) {",
      "        depth.assign(n, -1);",
      " ",
      "        for (int root : roots)",
      "            if (depth[root] < 0)",
      "                dfs(root, -1);",
      " ",
      "        for (int i = 0; i < n; i++)",
      "            if (depth[i] < 0)",
      "                dfs(i, -1);",
      " ",
      "        tour = 0;",
      "        euler.clear();",
      "        euler.reserve(2 * n);",
      " ",
      "        for (int i = 0; i < n; i++)",
      "            if (parent[i] < 0) {",
      "                tour_dfs(i, false);",
      "                // Add a -1 in between connected components to help us detect when nodes aren't connected.",
      "                euler.push_back(-1);",
      "            }",
      " ",
      "        assert(int(euler.size()) == 2 * n);",
      "        vector<int> euler_depth;",
      "        euler_depth.reserve(euler.size());",
      " ",
      "        for (int node : euler)",
      "            euler_depth.push_back(node < 0 ? node : depth[node]);",
      " ",
      "        if (build_rmq)",
      "            rmq.build(euler_depth);",
      " ",
      "        euler_depth.clear();",
      "        heavy_root_depth.resize(n);",
      "        heavy_root_parent.resize(n);",
      " ",
      "        for (int i = 0; i < n; i++) {",
      "            heavy_root_depth[i] = depth[heavy_root[i]];",
      "            heavy_root_parent[i] = parent[heavy_root[i]];",
      "        }",
      " ",
      "        rev_tour_list = tour_list;",
      "        reverse(rev_tour_list.begin(), rev_tour_list.end());",
      "        built = true;",
      "    }",
      " ",
      "    pair<int, array<int, 2>> get_diameter() const {",
      "        assert(built);",
      " ",
      "        // We find the maximum of depth[u] - 2 * depth[x] + depth[v] where u, x, v occur in order in the Euler tour.",
      "        pair<int, int> u_max = {-1, -1};",
      "        pair<int, int> ux_max = {-1, -1};",
      "        pair<int, array<int, 2>> uxv_max = {-1, {-1, -1}};",
      " ",
      "        for (int node : euler) {",
      "            if (node < 0) break;",
      "            u_max = max(u_max, {depth[node], node});",
      "            ux_max = max(ux_max, {u_max.first - 2 * depth[node], u_max.second});",
      "            uxv_max = max(uxv_max, {ux_max.first + depth[node], {ux_max.second, node}});",
      "        }",
      " ",
      "        return uxv_max;",
      "    }",
      " ",
      "    // Returns the center(s) of the tree (the midpoint(s) of the diameter).",
      "    array<int, 2> get_center() const {",
      "        pair<int, array<int, 2>> diam = get_diameter();",
      "        int length = diam.first, a = diam.second[0], b = diam.second[1];",
      "        return {get_kth_node_on_path(a, b, length / 2), get_kth_node_on_path(a, b, (length + 1) / 2)};",
      "    }",
      " ",
      "    // Note: returns -1 if `a` and `b` aren't connected.",
      "    int get_lca(int a, int b) const {",
      "        a = first_occurrence[a];",
      "        b = first_occurrence[b];",
      " ",
      "        if (a > b)",
      "            swap(a, b);",
      " ",
      "        return euler[rmq.query_index(a, b + 1)];",
      "    }",
      " ",
      "    bool is_ancestor(int a, int b) const {",
      "        return tour_start[a] <= tour_start[b] && tour_start[b] < tour_end[a];",
      "    }",
      " ",
      "    bool on_path(int x, int a, int b) const {",
      "        return (is_ancestor(x, a) || is_ancestor(x, b)) && is_ancestor(get_lca(a, b), x);",
      "    }",
      " ",
      "    int get_dist(int a, int b) const {",
      "        return depth[a] + depth[b] - 2 * depth[get_lca(a, b)];",
      "    }",
      " ",
      "    // Returns the child of `a` that is an ancestor of `b`. Assumes `a` is a strict ancestor of `b`.",
      "    int child_ancestor(int a, int b) const {",
      "        assert(a != b && is_ancestor(a, b));",
      " ",
      "        // Note: this depends on RMQ breaking ties by latest index.",
      "        int child = euler[rmq.query_index(first_occurrence[a], first_occurrence[b] + 1) + 1];",
      "        // assert(parent[child] == a && is_ancestor(child, b));",
      "        return child;",
      "    }",
      " ",
      "    int get_kth_ancestor(int a, int k) const {",
      "        if (k > depth[a])",
      "            return -1;",
      " ",
      "        int goal = depth[a] - k;",
      " ",
      "        while (heavy_root_depth[a] > goal)",
      "            a = heavy_root_parent[a];",
      " ",
      "        return tour_list[tour_start[a] + goal - depth[a]];",
      "    }",
      " ",
      "    int get_kth_node_on_path(int a, int b, int k) const {",
      "        int anc = get_lca(a, b);",
      "        int first_half = depth[a] - depth[anc];",
      "        int second_half = depth[b] - depth[anc];",
      " ",
      "        if (k < 0 || k > first_half + second_half)",
      "            return -1;",
      " ",
      "        if (k < first_half)",
      "            return get_kth_ancestor(a, k);",
      "        else",
      "            return get_kth_ancestor(b, first_half + second_half - k);",
      "    }",
      " ",
      "    // Note: this is the LCA of any two nodes out of three when the third node is the root.",
      "    // It is also the node with the minimum sum of distances to all three nodes (the centroid of the three nodes).",
      "    int get_common_node(int a, int b, int c) const {",
      "        // Return the deepest node among lca(a, b), lca(b, c), and lca(c, a).",
      "        int x = get_lca(a, b);",
      "        int y = get_lca(b, c);",
      "        int z = get_lca(c, a);",
      "        return x ^ y ^ z;",
      "    }",
      " ",
      "    // Given a subset of k tree nodes, computes the minimal subtree that contains all the nodes (at most 2k - 1 nodes).",
      "    // Returns a list of {node, parent} for every node in the subtree sorted by tour index. Runs in O(k log k).",
      "    // Note that all parents also appear as a node in the return value, and nodes[0].first is the compressed root.",
      "    vector<pair<int, int>> compress_tree(vector<int> nodes) const {",
      "        if (nodes.empty())",
      "            return {};",
      " ",
      "        auto compare_tour = [&](int a, int b) -> bool { return tour_start[a] < tour_start[b]; };",
      "        sort(nodes.begin(), nodes.end(), compare_tour);",
      "        int k = int(nodes.size());",
      " ",
      "        for (int i = 0; i < k - 1; i++)",
      "            nodes.push_back(get_lca(nodes[i], nodes[i + 1]));",
      " ",
      "        sort(nodes.begin() + k, nodes.end(), compare_tour);",
      "        inplace_merge(nodes.begin(), nodes.begin() + k, nodes.end(), compare_tour);",
      "        nodes.erase(unique(nodes.begin(), nodes.end()), nodes.end());",
      "        vector<pair<int, int>> result = {{nodes[0], -1}};",
      " ",
      "        for (int i = 1; i < int(nodes.size()); i++)",
      "            result.emplace_back(nodes[i], get_lca(nodes[i], nodes[i - 1]));",
      " ",
      "        return result;",
      "    }",
      "};"
    ],
    "description": ""
  },
}
